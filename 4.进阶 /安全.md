# 安全类

[前端安全](https://mubu.com/doc/Pb9lLOsHB)

## CSRF
Cross-site request forgery  跨站请求伪造

CSRF 就是利用用户的登录态发起恶意请求

### 攻击原理
1. 网站中某接口存在漏洞
2. 用户在该网站登陆过

### 如何防御
1. Token 验证
2. Referer 验证 （页面来源）
3. 隐藏令牌 

(
  1. Get 请求不对数据进行修改
  2. 不让第三方网站访问到用户 Cookie
  3. 阻止第三方网站请求接口
  4. 请求时附带验证信息，比如验证码或者 token
)


*SameSite*

可以对 Cookie 设置 SameSite 属性。该属性设置 Cookie 不随着跨域请求发送



## XSS
cross-site scripting 跨域脚本攻击
攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式(将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作)

攻击方式：XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。


### 分类
反射型（非持久型）、存储型（持久型）、基于DOM

反射型： 反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器
  - 攻击者诱使用户点击一个恶意链接,或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站

存储型: 存储型会把用户输入的数据 "存储" 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性

  - 比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码

基于DOM: 通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击


### 原理及防御措施

1. HttpOnly 防止劫取 Cookie
2. 输入检查(不要相信用户的任何输入)
3. 输出检查

输入输出：转义
白名单过滤

### 接口防刷
1. referer 校验 UA
2. c/s 约定签名算法， s 校验
3. s 对请求ip单位时间内请求数量做限制
4. 前置交互式验证。先验证再请求


## CSP
内容安全策略：
额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等

CSP 本质上也是建立白名单，规定了浏览器只能够执行特定来源的代码。

可以通过 HTTP Header 中的 Content-Security-Policy 来开启 CSP

```js

// 只允许加载本站资源
`Content-Security-Policy: default-src ‘self’`

// 只允许加载 HTTPS 协议图片
`Content-Security-Policy: img-src https://*`

// 允许加载任何来源框架
`Content-Security-Policy: child-src 'none'`
```

## 监控

对于代码运行错误，通常的办法是使用 `window.onerror` 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外

- 对于跨域的代码运行错误会显示 Script error. 对于这种情况我们需要给 script 标签添加 crossorigin 属性

- 对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 arguments.callee.caller 来做栈递归

- 对于异步代码来说，可以使用 catch 的方式捕获错误。比如 Promise 可以直接使用 catch 函数，async await 可以使用 try catch

- 但是要注意线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug。

- 对于捕获的错误需要上传给服务器，通常可以通过 img 标签的 src 发起一个请求



## 密码安全


### 加盐

密码存储来说，必然是不能明文存储在数据库中的，否则一旦数据库泄露，会对用户造成很大的损失。并且不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系。

通常需要对密码加盐，然后进行几次不同加密算法的加密。

```js
// 加盐也就是给原密码添加字符串，增加原密码长度
sha256(sha1(md5(salt + password + salt)))
```