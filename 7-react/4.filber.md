
## React16 以前

- React16 以前，对virtural dom的更新和渲染是同步的。

- 当一次更新或者一次加载开始以后，diff virtual dom并且渲染的过程是一口气完成的。

- 如果组件层级比较深，相应的堆栈也会很深，长时间占用浏览器主线程
  - 一些类似用户输入、鼠标滚动等操作得不到响应





## React16 Fiber Reconciler

react在进行组件渲染时，从setState开始到渲染完成整个过程是同步的（“一气呵成”）。如果需要渲染的组件比较庞大，js执行会占据主线程时间较长，会导致页面响应度变差.

React16 用了分片的方式解决上面的问题。

1. 把一个任务分成很多小片

2. 当分配给这个小片的时间用尽的时候，就检查任务列表中有没有新的、优先级更高的任务
  - 有就做这个新任务
  - 没有就继续做原来的任务

这种方式被叫做异步渲染(Async Rendering)。

fiber 可以让虚拟dom的diff可以被中断



### 卡顿原因
父组件里调子组件，可以类比为函数的递归。react 将所有的Virtual DOM遍历完成后，reconciler才能给出当前需要修改真实DOM的信息，并传递给renderer，进行渲染，然后屏幕上才会显示此次更新内容。对于特别庞大的vDOM树来说，reconciliation过程会很长，在这期间，主线程是被js占用的，因此任何交互、布局、渲染都会停止，给用户的感觉就是页面被卡住了。


### fiber-conciler
操作是可以分成很多小部分，并且可以被中断的。
整个结构是一个链表树。每个工作单元（fiber）执行完成后，都会查看是否还继续拥有主线程时间片，如果有继续下一个，如果没有则先处理其他高优先级事务，等主线程空闲下来继续执行